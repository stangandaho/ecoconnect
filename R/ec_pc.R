#' Calculate Probability of Connectivity (PC)
#'
#' This function calculates the Probability of Connectivity (PC) metric, which represents
#' the probability that two randomly selected locations within an ecoregion fall into
#' protected areas that are connected to each other. PC is one of the fundamental metrics
#' underlying the ProtConn indicator.
#'
#' @param pa sf object containing protected areas with a 'type' column distinguishing
#'   between "ecoregion" and "transboundary" areas, typically generated by [ec_add_transboundary_pa()]
#' @param max_prob_matrix Numeric matrix of maximum product probabilities between all
#'   protected areas, typically generated by [ec_max_product_probability()]
#' @param ecoregion_area sf object or total area of the ecoregion in(\eqn{\text{km}^2})
#'
#' @return Numeric value representing the PC metric (dimensionless, typically between 0 and 1)
#'
#' @details
#' The PC metric is calculated using the formula:
#' \deqn{PC = \frac{1}{A_L^2} \sum_{i=1}^{n} \sum_{j=1}^{n} a_i \times a_j \times p_{ij}^*}{%
#' PC = (1 / A_L^2) * sum_i sum_j (a_i * a_j * p_ij*)}
#'
#' where:
#' \itemize{
#'   \item \eqn{A_L} is the total area of the landscape/ecoregion
#'   \item \eqn{a_i} and \eqn{a_j} are the areas of protected areas i and j
#'   \item \eqn{p_{ij}^*} is the maximum probability of connection between areas i and j
#'   \item n is the number of protected areas within the ecoregion
#' }
#'
#' Note that only protected areas within the ecoregion are
#' considered as sources and destinations, though transboundary areas contribute to
#' connectivity as stepping stones.
#'
#' @inherit ec_dispersal_probability references
#' @examples
#' \donttest{
#' library(dplyr)
#' # Benin - treated as single ecoregion
#' benin <- fiwac %>%
#'   dplyr::filter(ISO3_CODE == "BEN")
#'
#' # Protected area
#' prot_area <- pas
#'
#' # repare data first
#' prepared_data <- ec_prepare_data(
#'   pa = prot_area,
#'   ecoregion = benin,
#'   min_area = 1
#' )
#'
#' # Add transboundary PAs with default 70km buffer
#' complete_pa <- ec_add_transboundary_pa(prepared_data, buffer_km = 70)
#'
#' # Calculate edge-to-edge distances
#' dist_matrix <- ec_pa_distances(complete_pa, method = "edge")
#'
#' # For a more mobile species (30km median dispersal)
#' prob_matrix <- ec_dispersal_probability(dist_matrix, median_dispersal = 30)
#'
#' # Limit to maximum 3 stepping stones
#' max_prob <- ec_max_product_probability(prob_matrix, max_steps = 3)
#'
#' # Calculate PC metric
#' pc_value <- ec_pc(
#'   pa = complete_pa,
#'   max_prob_matrix = max_prob,
#'   ecoregion_area = benin
#' )
#' }
#' @export
ec_pc <- function(pa,
                  max_prob_matrix,
                  ecoregion_area) {

  if (!"sf" %in% class(pa)) {
    cli::cli_abort("pa must be a simple feature object")
  }

  ecoregion_area <- ecoregion_area(ecoregion_area)
  not_trans <- which(pa$type != "transboundary")
  max_prob_matrix <- max_prob_matrix[not_trans, not_trans]
  pa_areas <- pa[not_trans, ] %>%
    dplyr::mutate("pa_area" = as.numeric(sf::st_area(.)) / 1e6)%>%
    dplyr::pull("pa_area")

  if (length(pa_areas) != nrow(max_prob_matrix)) {
    cli::cli_abort("Areas must have the same lenght as vertice size in max_prob_matrix")
  }
  n <- length(pa_areas)
  pc_sum <- 0

  for (i in 1:n) {
    for (j in 1:n) {
      pc_sum <- pc_sum + (pa_areas[i] * pa_areas[j] * max_prob_matrix[i, j])
    }
  }

  pc <- pc_sum / (ecoregion_area^2)
  return(pc)
}
