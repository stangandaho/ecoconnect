#' Calculate Maximum Product Probability Considering Stepping-Stone Paths
#'
#' This function calculates the maximum probability of reaching each destination protected area
#' considering both direct dispersal and indirect paths through intermediate protected areas
#' acting as "stepping stones". This accounts for the fact that species may reach distant
#' areas by making multiple shorter hops rather than one long-distance movement.
#'
#' @param prob_matrix Numeric matrix of direct dispersal probabilities between protected areas,
#'   typically generated by [ec_dispersal_probability()]
#' @param max_steps Integer or NULL. Maximum number of stepping stones to consider in path
#'   calculations. If NULL, considers all possible indirect paths (up to n-1 steps where n
#'   is the number of protected areas). Default is NULL
#'
#' @return A numeric matrix of maximum product probabilities where element represents
#'   the highest probability of reaching protected area j from protected area i, considering
#'   all possible direct and indirect paths. Values range from 0 to 1, with 1 on the diagonal
#'
#' @details
#' The function uses a dynamic programming approach similar to the Floyd-Warshall algorithm
#' to find optimal paths. For any two-step path i -> k -> j, the probability is calculated as:
#' \deqn{p_{i \to k \to j} = p_{ik} \times p_{kj}}
#'
#' The algorithm iteratively considers longer paths and retains the maximum probability
#' found for each origin-destination pair. This approach ensures that:
#' \itemize{
#'   \item Direct movements are considered when they provide the highest probability
#'   \item Indirect movements through stepping stones are considered when they provide
#'     higher probability than direct movement
#'   \item The optimal path (highest probability) is selected for each pair of areas
#' }
#'
#' Stepping-stone connectivity is particularly important for species with limited dispersal
#' ability, as it allows them to reach distant suitable habitat through a series of
#' shorter movements.
#'
#' @inherit ec_dispersal_probability references
#' @examples
#' \donttest{
#' library(dplyr)
#' # Benin - treated as single ecoregion
#' benin <- fiwac %>%
#'   dplyr::filter(ISO3_CODE == "BEN")
#'
#' # Protected area
#' prot_area <- pas
#'
#' # repare data first
#' prepared_data <- ec_prepare_data(
#'   pa = prot_area,
#'   ecoregion = benin,
#'   min_area = 1
#' )
#'
#' # Add transboundary PAs with default 70km buffer
#' complete_pa <- ec_add_transboundary_pa(prepared_data, buffer_km = 70)
#'
#' # Calculate edge-to-edge distances
#' dist_matrix <- ec_pa_distances(complete_pa, method = "edge")
#'
#' # For a more mobile species (30km median dispersal)
#' prob_matrix <- ec_dispersal_probability(dist_matrix, median_dispersal = 30)
#'
#' # Limit to maximum 3 stepping stones
#' max_prob <- ec_max_product_probability(prob_matrix, max_steps = 3)
#' max_prob[1:10, 1:10]
#' }
#' @export
ec_max_product_probability <- function(prob_matrix,
                                       max_steps = NULL) {
  # Ensure matrix
  n <- nrow(prob_matrix)
  steps_limit <- if (is.null(max_steps)) n else max_steps

  # Initialize with direct probabilities
  max_prob <- prob_matrix

  # Dynamic programming: Floydâ€“Warshall style
  for (step in 1:steps_limit) {
    for (k in 1:n) {
      for (i in 1:n) {
        for (j in 1:n) {
          # Check if going through k improves probability
          new_prob <- max_prob[i, k] * max_prob[k, j]
          if (new_prob > max_prob[i, j]) {
            max_prob[i, j] <- new_prob
          }
        }
      }
    }
  }

  # Ensure diagonal = 1 (self reachability)
  diag(max_prob) <- 1

  return(max_prob)
}
